# Cache 分布式缓存
Achieve Cache GO Like GroupCache、MemCache

## 1.LRU(Least Recently Used)

实现LRU淘汰算法两个核心数据结构

1.字典(map)，存储键(string)与值(list.Element链表节点)的关系。

2.双向链表实现的队列(list.List)

## 2.单机并发缓存

构建只读数据结构ByteView表示缓存值。用sync.Mutex封装LRU方法。

Group是最核心的数据结构，负责与用户的交互，并且控制缓存值存储和获取的流程。

Group.Get()实现缓存中存在直接获取，不存在则通过callback函数添加

```
                            是
接收 key --> 检查是否被缓存 -----> 返回缓存值 ⑴
                |  否                         是
                |-----> 是否应当从远程节点获取 -----> 与远程节点交互 --> 返回缓存值 ⑵
                            |  否
                            |-----> 调用`回调函数`，获取值并添加到缓存 --> 返回缓存值⑶
```

## 3.HTTP服务端

建立基于HTTP通信协议的分布式缓存节点间通信

访问格式 /<basepath>/<groupname>/<key>

通过groupname得到group实例，再使用group.Get(key)得到缓存数据

## 4.一致性哈希算法

***缓存雪崩：缓存在同一时刻全部失效，造成瞬时DB请求量大、压力骤增，引起雪崩。常因为缓存服务器宕机，或缓存设置了相同的过期时间引起。***:sound:

一致性哈希算法将 key 映射到 2^32 的空间中，将这个数字首尾相连，形成一个环。

引入虚拟节点解决节点较少时数据倾斜问题

默认采用***crc32.ChecksumIEEE***算法

## 5.分布式节点

```
使用一致性哈希选择节点        是                                    是
    |-----> 是否是远程节点 -----> HTTP 客户端访问远程节点 --> 成功？-----> 服务端返回返回值
                    |  否                                    ↓  否
                    |----------------------------> 回退到本地节点处理。
```

实现从远程节点获取缓存值

新增两个接口

PeerPicker 通过传入的key值选择响应节点PeerGetter

PeerGetter从对应的group上查找缓存值，对应http服务端

## 6.singleflight的实现防止缓存击穿

> **缓存雪崩**：缓存在同一时刻全部失效，造成瞬时DB请求量大、压力骤增，引起雪崩。缓存雪崩通常因为缓存服务器宕机、缓存的 key 设置了相同的过期时间等引起。

> **缓存击穿**：一个存在的key，在缓存过期的一刻，同时有大量的请求，这些请求都会击穿到 DB ，造成瞬时DB请求量大、压力骤增。

> **缓存穿透**：查询一个不存在的数据，因为不存在则不会写到缓存中，所以每次都会去请求 DB，如果瞬间流量过大，穿透到 DB，导致宕机。

并发的大量请求在没有该key缓存时会同时访问数据库，造成缓存击穿。

针对大量相同并发请求的key，只调用一次数据库获取值，其他的请求sync.GroupWait.Wait()等待直接返回值

